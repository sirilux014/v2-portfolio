<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Travel Journey | Smile Oracle</title>
    <style>
        :root {
            --bg-color: #87ceeb;
            /* Sky Blue */
            --accent-color: #0077be;
            --text-color: #333333;
            --panel-bg: rgba(255, 255, 255, 0.85);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            color: var(--text-color);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 4px;
            text-transform: uppercase;
            margin: 0;
            color: #222;
        }

        .camera-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .cam-btn {
            background: var(--panel-bg);
            border: 1px solid rgba(0, 0, 0, 0.1);
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            transition: all 0.2s;
            color: var(--text-color);
        }

        .cam-btn:hover {
            background: #fff;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .cam-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .status-box {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(15px);
            padding: 15px 30px;
            border-radius: 50px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            gap: 40px;
            align-items: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .status-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .status-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(0, 0, 0, 0.5);
        }

        .status-value {
            font-size: 1rem;
            color: var(--accent-color);
            font-weight: 600;
        }

        .footer {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.7rem;
            letter-spacing: 2px;
            color: rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body>

    <div class="overlay">
        <h1 class="title">THE DAYLIGHT EXPRESS</h1>
    </div>

    <div class="camera-controls">
        <button class="cam-btn active" onclick="setCamera('FREE')">FREE</button>
        <button class="cam-btn" onclick="setCamera('FOLLOW')">FOLLOW</button>
        <button class="cam-btn" onclick="setCamera('DRIVER')">DRIVER</button>
        <button class="cam-btn" onclick="setCamera('TOP')">TOP</button>
        <button class="cam-btn" onclick="setCamera('SIDE')">SIDE</button>
    </div>

    <div id="canvas-container"></div>

    <div class="status-box">
        <div class="status-item">
            <span class="status-label">Current Location</span>
            <span class="status-value" id="loc">Detecting...</span>
        </div>
        <div class="status-item">
            <span class="status-label">Battery Level</span>
            <span class="status-value" id="batt">--%</span>
        </div>
        <div class="status-item">
            <span class="status-label">Environment</span>
            <span class="status-value">Daytime</span>
        </div>
    </div>

    <div class="footer">
        3D SIMULATION BY SMILE ORACLE
    </div>

    <!-- Scripts -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        let scene, camera, renderer, controls;
        let train, routeCurve;
        let pointsData = [];
        let waypoints = [];
        let fraction = 0;
        const trainSpeed = 0.0005; // speed along path
        let cameraMode = 'FREE'; // FREE, FOLLOW, TOP, SIDE

        // Exposed to global for button clicks
        window.setCamera = (mode) => {
            cameraMode = mode;
            document.querySelectorAll('.cam-btn').forEach(btn => {
                btn.classList.toggle('active', btn.innerText === mode);
            });
            if (mode === 'FREE') {
                controls.enabled = true;
            } else {
                controls.enabled = false;
            }
        };

        // --- Init Function ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Day Sky
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.001);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 8000);
            camera.position.set(300, 300, 500);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(500, 1000, 200);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // Ground
            const groundGeom = new THREE.PlaneGeometry(8000, 8000);
            const groundMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -6;
            ground.receiveShadow = true;
            scene.add(ground);

            const grid = new THREE.GridHelper(8000, 100, 0xcccccc, 0xdddddd);
            grid.position.y = -5.9;
            scene.add(grid);

            // Start Loading Data
            loadCSV();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        async function loadCSV() {
            const response = await fetch('travel-phitsanulok.csv');
            const csvText = await response.text();

            Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function (results) {
                    pointsData = results.data;
                    processPoints();
                }
            });
        }

        function processPoints() {
            if (pointsData.length === 0) return;

            // Simple Projection: Normalize base coordinates
            // Use Phitsanulok roughly as center for coordinate system
            const centerLat = 17.5;
            const centerLon = 99.5;
            const scale = 800; // units per degree

            waypoints = pointsData.map(pt => {
                if (!pt.lat || !pt.lon) return null;
                return new THREE.Vector3(
                    (pt.lon - centerLon) * scale,
                    0,
                    (centerLat - pt.lat) * scale // Z is flipped in 3D maps usually
                );
            }).filter(p => p !== null);

            if (waypoints.length < 2) return;

            // Create Curve
            routeCurve = new THREE.CatmullRomCurve3(waypoints);

            // Draw route on ground
            const pathPoints = routeCurve.getPoints(1000);
            const pathGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
            const pathMaterial = new THREE.LineBasicMaterial({ color: 0x0077be, linewidth: 2 });
            const pathLine = new THREE.Line(pathGeometry, pathMaterial);
            scene.add(pathLine);

            createTrain();
        }

        function createTrain() {
            const trainGroup = new THREE.Group();

            // Train Engine
            const bodyGeom = new THREE.BoxGeometry(8, 6, 16);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xcc0000 });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.castShadow = true;
            trainGroup.add(body);

            const cabinGeom = new THREE.BoxGeometry(7, 4, 7);
            const cabinMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const cabin = new THREE.Mesh(cabinGeom, cabinMat);
            cabin.position.set(0, 5, -3);
            trainGroup.add(cabin);

            // Nose
            const noseGeom = new THREE.CylinderGeometry(3, 3, 4, 32);
            noseGeom.rotateX(Math.PI / 2);
            const nose = new THREE.Mesh(noseGeom, bodyMat);
            nose.position.set(0, -1, 8);
            trainGroup.add(nose);

            train = trainGroup;
            scene.add(train);
        }

        function updateCamera() {
            if (!train || !routeCurve) return;

            const pos = train.position.clone();
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(train.quaternion).normalize();
            const up = new THREE.Vector3(0, 1, 0);
            const side = new THREE.Vector3().crossVectors(forward, up).normalize();

            if (cameraMode === 'FOLLOW') {
                const targetPos = pos.clone().sub(forward.clone().multiplyScalar(60)).add(up.clone().multiplyScalar(30));
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(pos.clone().add(forward.clone().multiplyScalar(20)));
            }
            else if (cameraMode === 'DRIVER') {
                const targetPos = pos.clone().add(forward.clone().multiplyScalar(8)).add(up.clone().multiplyScalar(4));
                camera.position.copy(targetPos);
                camera.lookAt(pos.clone().add(forward.clone().multiplyScalar(50)));
            }
            else if (cameraMode === 'TOP') {
                const targetPos = pos.clone().add(up.clone().multiplyScalar(200));
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(pos);
            }
            else if (cameraMode === 'SIDE') {
                const targetPos = pos.clone().add(side.clone().multiplyScalar(80)).add(up.clone().multiplyScalar(20));
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(pos);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (cameraMode === 'FREE') {
                controls.update();
            }

            if (train && routeCurve) {
                fraction += trainSpeed;
                if (fraction > 1) fraction = 0;

                const position = routeCurve.getPointAt(fraction);
                const nextPosition = routeCurve.getPointAt((fraction + 0.001) % 1);

                train.position.copy(position);
                train.lookAt(nextPosition);

                updateCamera();

                // Update UI based on current index
                const idx = Math.floor(fraction * pointsData.length);
                const currentData = pointsData[Math.min(idx, pointsData.length - 1)];
                if (currentData) {
                    document.getElementById('loc').innerText = currentData.locality || "On Transit";
                    document.getElementById('batt').innerText = currentData.battery + "%";
                }
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>