<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DustBoy 3D Metaverse | Smile Oracle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            cursor: crosshair;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-top {
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00e5ff;
            letter-spacing: 5px;
            font-weight: 800;
            font-size: 1.2rem;
            text-shadow: 0 0 10px #00e5ff;
        }

        .hud-status {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: rgba(255, 255, 255, 0.5);
            font-family: monospace;
            font-size: 0.8rem;
        }

        .hud-stats {
            position: absolute;
            bottom: 30px;
            right: 30px;
            text-align: right;
            color: rgba(255, 255, 255, 0.5);
            font-family: monospace;
            font-size: 0.8rem;
        }

        #connection-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #ff5252;
            border-radius: 50%;
            margin-right: 5px;
            box-shadow: 0 0 10px #ff5252;
        }

        #connection-dot.active {
            background: #00e676;
            box-shadow: 0 0 10px #00e676;
        }

        .station-label {
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 12px;
            border-radius: 4px;
            border-left: 3px solid #00e5ff;
            font-size: 0.7rem;
            pointer-events: none;
            opacity: 0.8;
        }

        .pm-bubble {
            font-weight: 800;
            color: #00e5ff;
            font-size: 1.2rem;
        }

        canvas {
            display: block;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;800&display=swap" rel="stylesheet">
</head>

<body>

    <div id="ui-layer">
        <div class="hud-top">DUSTBOY METAVERSE LAB</div>
        <div class="hud-status">
            <span id="connection-dot"></span> CONNECTION: <span id="status-text">INITIATING...</span><br>
            TOPIC: DUSTBOY/+/+/+/status
        </div>
        <div class="hud-stats">
            ACTIVE NODES: <span id="node-count">0</span><br>
            SMILE ORACLE QUANTUM ENGINE V1.0
        </div>
    </div>

    <!-- Scripts -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.156.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.156.1/examples/jsm/"
        }
    }
    </script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.0/tween.umd.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        let scene, camera, renderer, labelRenderer, controls;
        let particles, starGeo;
        const stationMeshes = new Map();
        const stationLabels = new Map();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 200, 600);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Label Renderer
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0x00e5ff, 1, 1000);
            pointLight.position.set(0, 500, 0);
            scene.add(pointLight);

            // Starfield
            starGeo = new THREE.BufferGeometry();
            const starCoords = [];
            for (let i = 0; i < 6000; i++) {
                starCoords.push(THREE.MathUtils.randFloatSpread(2000));
                starCoords.push(THREE.MathUtils.randFloatSpread(2000));
                starCoords.push(THREE.MathUtils.randFloatSpread(2000));
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
            const starMat = new THREE.PointsMaterial({ color: 0x888888, size: 0.7 });
            particles = new THREE.Points(starGeo, starMat);
            scene.add(particles);

            // Ground Grid
            const grid = new THREE.GridHelper(2000, 40, 0x00e5ff, 0x111111);
            grid.position.y = -100;
            scene.add(grid);

            window.addEventListener('resize', onWindowResize);
            animate();
            connectMQTT();
        }

        function connectMQTT() {
            const client = mqtt.connect('wss://dustboy-wss-bridge.laris.workers.dev/mqtt');
            const dot = document.getElementById('connection-dot');
            const statusText = document.getElementById('status-text');

            client.on('connect', () => {
                dot.classList.add('active');
                statusText.innerText = 'ONLINE';
                // Subscribe to EVERY DUSTBOY topic to capture all metadata
                client.subscribe('DUSTBOY/#');
            });

            client.on('message', (topic, message) => {
                const msgStr = message.toString();

                try {
                    // Handling raw "offline" string
                    if (msgStr === 'offline') {
                        onDataReceived(topic, { status: 'offline' });
                        return;
                    }

                    // Handling raw numbers - check topic to decide which field it is
                    if (!isNaN(msgStr) && msgStr.trim() !== '') {
                        const value = parseFloat(msgStr);
                        const update = {};
                        if (topic.endsWith('/pm25')) update.pm25 = value;
                        else if (topic.endsWith('/pm10')) update.pm10 = value;
                        else if (topic.endsWith('/temp')) update.temp = value;
                        else if (topic.endsWith('/hum')) update.hum = value;
                        else if (topic.endsWith('/status')) update.pm25 = value; // Sometimes status is a number

                        if (Object.keys(update).length > 0) {
                            onDataReceived(topic, update);
                        }
                        return;
                    }

                    const rawData = JSON.parse(msgStr);
                    const data = rawData.data || rawData;
                    onDataReceived(topic, data);
                } catch (e) {
                    // Ignore parsing errors for non-JSON payloads
                }
            });

            client.on('error', (err) => {
                statusText.innerText = 'ERROR';
                dot.classList.remove('active');
                console.error('MQTT Error:', err);
            });
        }

        function onDataReceived(topic, data) {
            const parts = topic.split('/');
            // Smart ID extraction: find the part that looks like a station ID (e.g., N-xxx or just the last numeric part)
            // If topic is DUSTBOY/Model-N/WiFi/N-172/status -> parts[3] is N-172
            // If topic is DUSTBOY/N-143/status -> parts[1] is N-143
            let id = 'Unknown';
            if (parts.length >= 5) id = parts[3]; // Standard 5-level topic
            else if (parts.length >= 3) id = parts[1]; // Narrow 3-level topic
            else id = parts[parts.length - 2] || 'Unknown';

            // Extract values only if they exist in this specific message
            const newPm25 = data.pm25 !== undefined ? data.pm25 :
                data.pm2_5 !== undefined ? data.pm2_5 :
                    data.pm25_value !== undefined ? data.pm25_value : undefined;

            const isOffline = data.status === 'offline' || topic.endsWith('/offline');
            const nickname = data.nickname || data.nickname_th || id;

            if (!stationMeshes.has(id)) {
                const group = new THREE.Group();
                const geo = new THREE.IcosahedronGeometry(20, 0);
                const mat = new THREE.MeshPhongMaterial({ color: 0x00e5ff, wireframe: true, transparent: true, opacity: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
                group.add(mesh);

                const innerGeo = new THREE.IcosahedronGeometry(10, 0);
                const innerMat = new THREE.MeshBasicMaterial({ color: 0x00e5ff });
                const innerMesh = new THREE.Mesh(innerGeo, innerMat);
                group.add(innerMesh);

                group.position.set(THREE.MathUtils.randFloatSpread(1500), THREE.MathUtils.randFloat(0, 500), THREE.MathUtils.randFloatSpread(1500));
                scene.add(group);

                // Store state in the group object for persistent access
                group.userData = { id, pm25: 0, nickname: nickname };
                stationMeshes.set(id, group);

                const labelDiv = document.createElement('div');
                labelDiv.className = 'station-label';
                labelDiv.innerHTML = `${nickname}<br><span class="pm-bubble" id="pm-${id}">0.0</span>`;
                const label = new CSS2DObject(labelDiv);
                label.position.set(0, 55, 0);
                group.add(label);
                stationLabels.set(id, labelDiv);

                document.getElementById('node-count').innerText = stationMeshes.size;
            }

            const group = stationMeshes.get(id);
            const core = group.children[1];
            const shell = group.children[0];
            const pmBubble = document.getElementById(`pm-${id}`);

            // Only update PM25 if it's present in this message
            if (newPm25 !== undefined) {
                group.userData.pm25 = parseFloat(newPm25);
            }

            if (isOffline) group.userData.isOffline = true;
            else if (data.status === 'online' || newPm25 !== undefined) group.userData.isOffline = false;

            const currentPm25 = group.userData.pm25;
            const currentOffline = group.userData.isOffline;

            if (pmBubble) {
                if (currentOffline) {
                    pmBubble.innerText = 'OFF';
                    pmBubble.style.color = '#555';
                } else {
                    pmBubble.innerText = currentPm25.toFixed(1);
                    pmBubble.style.color = '#00e5ff';
                }
            }

            let color = new THREE.Color(0x00e676);
            if (currentOffline) color = new THREE.Color(0x222222);
            else if (currentPm25 > 150) color = new THREE.Color(0xff1744);
            else if (currentPm25 > 55) color = new THREE.Color(0xff9100);
            else if (currentPm25 > 35) color = new THREE.Color(0xffea00);

            core.material.color.lerp(color, 0.2);
            shell.material.color.lerp(color, 0.2);

            const targetScale = currentOffline ? 0.3 : Math.max(0.5, Math.min(currentPm25 / 30, 6));
            new TWEEN.Tween(group.scale).to({ x: targetScale, y: targetScale, z: targetScale }, 800).easing(TWEEN.Easing.Quadratic.Out).start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();

            // Floating animation for entities
            const time = performance.now() * 0.001;
            stationMeshes.forEach((group, id) => {
                group.position.y += Math.sin(time + group.position.x) * 0.2;
                group.rotation.y += 0.01;
            });

            // Twinkle stars
            particles.rotation.y += 0.0005;

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>